$Id: README,v 1.1 2007/03/15 07:40:54 ygeorgie Exp $
+-------------------------------------------------+
|  Author:          Yury Georgievskiy from AB/CO  |
|  Creation date:   01.06.2006                    |
|  Current version: 2 (as of 18.07.2006)          |
|  State:           Techical note                 |
+-------------------------------------------------+


###############################################################################
#                       CDCM technical notes.                                 #
###############################################################################

First of all - pay in mind, that it's (still) not perfect. 
There are some rules and limitations on HOWTO use CDCM.
One should take care following this rules and limitations.

Here comes the 'limitation list' 


1. Some functions should be implement by the user, namely those, who prefixed
   with 'cdcm_user_part'. They all are located in cdcmUsr.[ch] files.
   CDCM expects them to exist. They should return 'cdcmerr' values (defined in
   cdcm.h module). cdcmerr_noerr - in case of success or negative values 
   othervise. These functions are:

   A. cdcm_user_part_device_recodnizer
   B. cdcm_user_part_get_ioctl_directives


2. 'struct file' that is passed into the common part of the LynxOS-like code 
    is screwed up in case of Linux!! It's adapted partially.


3. Stream task limitatioins.
----------------------------
   For now there is no way to emulate LynxOS threads completely.
   The 'oblitary code demand' concerns a function that is passed as a payload 
   function to 'ststart' call (firs parameter of ststart). 
   Let's examain it in more details:
   Usually, a stream task payload is looped in a cycle, doing it's work.
   The demand for this functions is that
   EACH TIME BEFORE TO JUMP TO THE BEGINNING OF THE LOOP - ONE SHOULD INSERT
   A PREDEFINED CDCM MACRO IN IT'S CODE.
   The macro is 'CDCM_LOOP_AGAIN'.

   The only perpose of this macro is to be able to quit (or to kill, as you
   prefer) system thread on Linux platform. Othervise it's not possible to get
   out of the 'for' loop. Note that we are speaking only about Linux platform.
   Want to know why? Here you go:
   It's not possible to add signal handler to kernel thread in Linux.
   They will never been called. Signals are delivered only on exit from kernel
   mode (which happens either at the end of a syscall or after interrupt, which
   may have caused the signal), scheduling being a special case ot this.
   Since kernel thread never leaves a kernel mode, the code to run signal
   handlers is never executed.

   Here are some examples that illustrates how stream task should look like
   in CDCM:

--------------------------------------------------------------------
	Normal Lynx thread        |        CDCM adapted Lynx thread
----------------------------------|---------------------------------
                                  |
   void kthread(void param) {     |   void kthread(void param) {     
	  for (;;) {              |          for (;;) {  
	    ....                  |            ...
	    /* do the job */      |            /* do the job */ 
	    ...                   |            ... 
	  }                       |            CDCM_LOOP_AGAIN;
	}                         |          } 
                                  |        }
----------------------------------|---------------------------------
                                  |
   void kthread(void param) {     |   void kthread(void param) {
	  do {                    |          do {
	    ...                   |            ...
	    /* payload */         |            /* payload */
	    ...                   |            ... 
	  } while (1)             |            CDCM_LOOP_AGAIN;  
	}                         |          } while (1)
                                  |        }
----------------------------------|---------------------------------     
                                  |
   void kthread(void param) {     |    void kthread(void param) {
	tag:                      |         tag: 
	...                       |         ...
	/* do the job here */     |         /* do the job here */
	...                       |         ...
	goto tag;                 |         CDCM_LOOP_AGAIN; 
	}                         |         goto tag;
                                  |         }
--------------------------------------------------------------------

   As you can see - all 'adapted' functions contain CDCM_LOOP_AGAIN macro just
   before the end of the loop cycle. This is the bottleneck of thread stub
   implementation, because already existing driver code will not be completely
   portable. It should be affected (CDCM_LOOP_AGAIN macro insertion) to be
   able to run under Linux.


4. Copy data to/from user address space.
----------------------------------------
   Special CDCM functions can be used when transferring data to/from user
   address space. These functions are:

   A. cdcm_copy_from_user
   B. cdcm_copy_to_user
